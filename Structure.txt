project/
├── app.py
├── models
│   ├── tracks.py
│   ├── radios.py
│   └── ...
├── core
│   ├── __init__.py
│   ├── utils.py
│   └── ...
├── apiv1.py
├── apiv2.py
└── apis
    ├── __init__.py
    ├── radios_api.py
    ├── tracks_api.py
    ├── ...
    └── namespaceX.py

################## Flask config #####################
from flask import Flask
app = Flask(
    __name__,
    instance_relative_config=False,
    template_folder="templates",
    static_folder="static"
)

################ import route function ######################
from flask import Flask
from logic import square_of_number_plus_nine
app = Flask(__name__)


@app.route("/")
def hello():
    value = square_of_number_plus_nine(5)
    return value

############## Markup #########################
from flask import Flask, Markup
app = Flask(__name__)


@app.route("/")
def hello():
    return Markup("<h1>Hello World!</h1>")

############# Response ########################
from flask import Flask, make_response
app = Flask(__name__)

@app.route("/")
def hello():
    headers = {"Content-Type": "application/json"}
    return make_response('it worked!', 200, headers)


############ Check for method types ###############
from flask import Flask, make_response, request
app = Flask(__name__)

@app.route("/", methods=['GET'])
def hello():
    if request.method != 'GET':
        return make_response('Malformed request', 400)
    headers = {"Content-Type": "application/json"}
    return make_response('it worked!', 200, headers)

################## Jsonify ########################
from flask import Flask, make_response, request, jsonify
app = Flask(__name__)

@app.route("/", methods=['GET'])
def hello():
    if request.method != 'GET':
        return make_response('Malformed request', 400)
    my_dict = {'key': 'dictionary value'}
    headers = {"Content-Type": "application/json"}
    return make_response(jsonify(my_dict), 200, headers)

################# JINJA nav dynamic #############
@app.route('/')
def home():
    """Landing page."""
    nav = [{'name': 'Home', 'url': 'https://example.com/1'},
           {'name': 'About', 'url': 'https://example.com/2'},
           {'name': 'Pics', 'url': 'https://example.com/3'}]
    return render_template('home.html',
                           nav=nav,
                           title="Jinja Demo Site",
                           description="Smarter page templates \
                                with Flask & Jinja.")

########################## Routes Dynamics ################
@app.route('/user/<username>')
def profile(username):
    ...

@app.route('/<int:year>/<int:month>/<title>')
def article(year, month, title):
    ...
##################### Redirects ######################
@app.route("/login")
def login():
    return redirect(url_for('dashboard'))


########### Errors ################
@app.errorhandler(404)
def not_found():
    """Page not found."""
    return make_response(render_template("404.html"), 404)


@app.errorhandler(400)
def bad_request():
    """Bad request."""
    return make_response(render_template("400.html"), 400)


@app.errorhandler(500)
def server_error():
    """Internal server error."""
    return make_response(render_template("500.html"), 500)

# Requests
request.method:
Contains the method used to access a route, such as GET or POST.
request.method is absolutely essential for building smart routes: we can use this logic to have one route serve multiple different
responses depending on what method was used to call said route. This is how REST APIs provide different results on a GET request
versus a POST request ( if request.method == 'POST': can open a block only pertaining to POST requests in our route).

request.args:
Contains the query-string parameters of a request that hit our route.
If we're building an endpoint that accepts a url parameter, for example, we can get this from the request as request.args.get('url’).

request.data:
Returns the body of an object posted to a route.

request.form:
If a user hits this route as a result of form submission, request.form is our way of accessing the information the form posted.
For example, to fetch the provided username of a submitted form, request.form['username'] is used.

request.headers:
Contains the HTTP response headers of a request.

########### Decorators #################

@app.before_request():
Defining a function with the .before_request() decorator will execute said function before every request is made.
Examples of when we might use this could include things like tracking user actions, determining user permissions, or
adding a "back button" feature by remembering the last page the user visited before loading the next.

@app.endpoint('function_name'): Setting an "endpoint" is an alternative to @app.route() that accomplishes the same
effect of mapping URLs to logic. This is a fairly advanced use-case which comes into play in larger applications when
certain logic must transverse modules known as Blueprints (don't worry if this terminology sounds like nonsense — most
people will likely never run into a use case for endpoints).

@login_required (from Flask-Login): Slap this before any route to immediately protect it from being accessed
from logged-out users. If the user is logged in, @login_required lets them in accordingly. If you're interested in user
account management in Flask, check our post about Flask-Login.

@expose (from Flask-Admin):
Allows views to be created for a custom admin panel.

@cache.cached() (from Flask-Cache):
Cache routes for a set period of time, ie:  @cache.cached(timeout=50).

api = Api(app,
          version='10.5',
          title='Flask Restplus Demo',
          description='Demo to show various API parameters',
          license='MIT',
          contact='Jimit Dholakia',
          contact_url='https://in.linkedin.com/in/jimit105',
          doc = '/docs/',
          prefix='/test'
          )

version → API Version (for Swagger Documentation)
title → API title (for Swagger Documentation)
description → API Description (for Swagger Documentation)
license → Specify License for the API (for Swagger Documentation)
license_url → Specify the License page URL (for Swagger Documentation)
contact → Specify contact person (for Swagger Documentation)
contact_email → Specify the email address of contact person (for Swagger Documentation)
contact_url → Specify URL to contact person (for Swagger Documentation)
doc → Specify the path for Swagger UI Documentation. Defaults to '/'
prefix → Specify a prefix for all endpoints of the URL



Models
A model defines the structure/schema of the payload of a request or response. This includes the list of all fields and their types. I keep all my models in a separate folder ./src/models

from flask_restplus import fields
from server.instance import server

book = server.api.model('Book', {
    'id': fields.Integer(description='Id'),
    'title': fields.String(required=True, min_length=1, max_length=200, description='Book title')
})


Resources
A resource is a class whose methods are mapped to an API/URL endpoint. We use flask-restplus annotations to define the URL pattern for every such class. For every resources class, the method whose names match the HTTP methods (e.g. get, put) will handle the matching HTTP calls.

By using the expect annotation, for every HTTP method we can specify the expected model of the payload body. Similarly, by using the marshal annotations, we can define the respective response payload model.

I keep my resources in the ./src/resources folder. Let’s create a simple resource ./src/resources/book.py:

from flask import Flask
from flask_restplus import Api, Resource, fields
from server.instance import server
from models.book import book

app, api = server.app, server.api

# Let's just keep them in memory
books_db = [
    {"id": 0, "title": "War and Peace"},
    {"id": 1, "title": "Python for Dummies"},
]

# This class will handle GET and POST to /books
@api.route('/books')
class BookList(Resource):
    @api.marshal_list_with(book)
    def get(self):
        return books_db

    # Ask flask_restplus to validate the incoming payload
    @api.expect(book, validate=True)
    @api.marshal_with(book)
    def post(self):
        # Generate new Id
        api.payload["id"] = books_db[-1]["id"] + 1 if len(books_db) > 0 else 0
        books_db.append(api.payload)
        return api.payload

# Handles GET and PUT to /books/:id
# The path parameter will be supplied as a parameter to every method
@api.route('/books/<int:id>')
class Book(Resource):
    # Utility method
    def find_one(self, id):
        return next((b for b in books_db if b["id"] == id), None)

    @api.marshal_with(book)
    def get(self, id):
        match = self.find_one(id)
        return match if match else ("Not found", 404)

    @api.marshal_with(book)
    def delete(self, id):
        global books_db
        match = self.find_one(id)
        books_db = list(filter(lambda b: b["id"] != id, books_db))
        return match

    # Ask flask_restplus to validate the incoming payload
    @api.expect(book, validate=True)
    @api.marshal_with(book)
    def put(self, id):
        match = self.find_one(id)
        if match != None:
            match.update(api.payload)
            match["id"] = id
        return match


sample-python-api/
 │
 ├── .python-version
 ├── Pipfile
 ├── Pipfile.lock
 └── src
     ├── environment
     │   └── instance.py
     ├── models
     │   └── book.py
     ├── resources
     │   └── book.py
     └── server
         └── instance.py


├── __init__.py
├── controller.py
├── controller_test.py
├── interface.py
├── interface_test.py
├── model.py
├── model_test.py
├── schema.py
├── schema_test.py
├── service.py
└── service_test.py

project/
├── app.py
├── models
│   ├── Tracks.py
│   ├── Radios.py
│   └── ...
├── schemas (marshmellow etc.)
│   ├── tracks.py
│   ├── radios.py
│   └── ...
├── core
│   ├── __init__.py
│   ├── utils.py
│   └── ...
├── apiv1.py
├── apiv2.py
└── apis
    ├── __init__.py
    ├── radios_api.py
    ├── tracks_api.py
    ├── ...
    └── namespaceX.py


├── api                         #
│   ├── blog                    #  Blog-related API directory
│   │   ├── business.py         #
│   │   ├── endpoints           #  API namespaces and REST methods
│   │   │   ├── categories.py   #
│   │   │   └── posts.py        #
│   │   ├── parsers.py          #  Argument parsers
│   │   └── serializers.py      #  Output serializers
│   └── restplus.py             #  API bootstrap file
├── app.py                      #  Application bootstrap file
├── database                    #
│   └── models.py               #  Definition of SQLAlchemy models
├── db.sqlite                   #
└── settings.py                 #  Global app settings


def initialize_app(flask_app):
    configure_app(flask_app)

    blueprint = Blueprint('api', __name__, url_prefix='/api')
    api.init_app(blueprint)
    api.add_namespace(blog_posts_namespace)
    api.add_namespace(blog_categories_namespace)
    flask_app.register_blueprint(blueprint)

    db.init_app(flask_app)




from flask_restplus import reqparse

pagination_arguments = reqparse.RequestParser()
pagination_arguments.add_argument('page', type=int, required=False)
pagination_arguments.add_argument('per_page', type=int, required=False,
                                  choices=[5, 10, 20, 30, 40, 50], default=10)

@ns.route('/')
class PostsCollection(Resource):

    @api.expect(pagination_arguments, validate=True)
    def get(self):
        ...
app.config['RESTPLUS_VALIDATE'] = True
